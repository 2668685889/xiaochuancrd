# 进销存管理系统 - 前端组件开发指南

## 概述

本指南详细说明前端组件的开发规范、最佳实践和代码示例，确保代码质量和一致性。

## 组件开发原则

### 1. 单一职责原则
- 每个组件只负责一个特定功能
- 避免创建过于复杂的组件
- 合理拆分大型组件为小型可复用组件

### 2. 可复用性原则
- 设计通用的基础组件
- 提供灵活的配置选项
- 支持插槽和组合模式

### 3. 可维护性原则
- 清晰的组件接口
- 完善的类型定义
- 详细的文档注释

## 组件分类

### 1. 基础UI组件 (Base Components)
- 按钮、输入框、选择器等基础元素
- 不包含业务逻辑
- 高度可配置和可复用

### 2. 业务组件 (Business Components)
- 包含特定业务逻辑
- 组合基础组件实现功能
- 如产品表单、库存列表等

### 3. 页面组件 (Page Components)
- 完整的页面视图
- 组合多个业务组件
- 处理页面级状态和路由

## 组件文件结构

### 标准组件结构
```
src/components/
├── ui/                          # 基础UI组件
│   ├── Button/
│   │   ├── Button.tsx           # 组件实现
│   │   ├── Button.stories.tsx   # Storybook故事
│   │   ├── Button.test.tsx      # 单元测试
│   │   ├── index.ts             # 导出文件
│   │   └── types.ts             # 类型定义
│   └── Input/
│       ├── Input.tsx
│       ├── Input.stories.tsx
│       ├── Input.test.tsx
│       ├── index.ts
│       └── types.ts
├── forms/                       # 表单组件
│   ├── ProductForm/
│   │   ├── ProductForm.tsx
│   │   ├── ProductForm.stories.tsx
│   │   ├── ProductForm.test.tsx
│   │   ├── index.ts
│   │   └── types.ts
│   └── SupplierForm/
│       ├── SupplierForm.tsx
│       ├── SupplierForm.stories.tsx
│       ├── SupplierForm.test.tsx
│       ├── index.ts
│       └── types.ts
└── tables/                      # 表格组件
    ├── DataTable/
    │   ├── DataTable.tsx
    │   ├── DataTable.stories.tsx
    │   ├── DataTable.test.tsx
    │   ├── index.ts
    │   └── types.ts
    └── InventoryTable/
        ├── InventoryTable.tsx
        ├── InventoryTable.stories.tsx
        ├── InventoryTable.test.tsx
        ├── index.ts
        └── types.ts
```

## 组件开发规范

### 1. 命名规范

#### 文件命名
```typescript
// 组件文件 - PascalCase
Button.tsx
ProductForm.tsx
InventoryTable.tsx

// 工具文件 - camelCase
apiClient.ts
formatUtils.ts
validationRules.ts

// 样式文件 - kebab-case
button.module.css
product-form.module.css
```

#### 组件命名
```typescript
// 页面组件 - Page后缀
InventoryPage.tsx
ProductPage.tsx
ReportPage.tsx

// 布局组件 - Layout后缀
MainLayout.tsx
SidebarLayout.tsx

// 表单组件 - Form后缀
ProductForm.tsx
SupplierForm.tsx

// 列表组件 - List后缀
InventoryList.tsx
OrderList.tsx

// 卡片组件 - Card后缀
ProductCard.tsx
SupplierCard.tsx
```

### 2. Props接口设计

#### 基础组件Props
```typescript
// Button组件Props
interface ButtonProps {
  /** 按钮类型 */
  variant?: 'primary' | 'secondary' | 'danger' | 'success';
  /** 按钮尺寸 */
  size?: 'sm' | 'md' | 'lg';
  /** 是否禁用 */
  disabled?: boolean;
  /** 加载状态 */
  loading?: boolean;
  /** 点击事件 */
  onClick?: (event: React.MouseEvent) => void;
  /** 子元素 */
  children: React.ReactNode;
  /** 自定义类名 */
  className?: string;
}
```

#### 业务组件Props
```typescript
// ProductForm组件Props
interface ProductFormProps {
  /** 初始数据 */
  initialData?: Partial<Product>;
  /** 编辑模式 */
  isEdit?: boolean;
  /** 提交回调 */
  onSubmit: (data: CreateProductRequest) => Promise<void>;
  /** 取消回调 */
  onCancel?: () => void;
  /** 加载状态 */
  loading?: boolean;
  /** 供应商列表 */
  suppliers: Supplier[];
}
```

### 3. 状态管理规范

#### 使用自定义Hooks
```typescript
// 产品表单状态管理
function useProductForm(initialData?: Partial<Product>) {
  const [formData, setFormData] = useState<CreateProductRequest>({
    productName: '',
    productCode: '',
    unitPrice: 0,
    currentQuantity: 0,
    minQuantity: 0,
    maxQuantity: 0,
    supplierUuid: '',
    ...initialData
  });

  const [errors, setErrors] = useState<Record<string, string>>({});
  const [touched, setTouched] = useState<Record<string, boolean>>({});

  const updateField = (field: keyof CreateProductRequest, value: any) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    
    // 清除该字段的错误
    if (errors[field]) {
      setErrors(prev => ({ ...prev, [field]: '' }));
    }
  };

  const validateField = (field: keyof CreateProductRequest) => {
    const error = validateProductField(field, formData[field]);
    setErrors(prev => ({ ...prev, [field]: error }));
    return !error;
  };

  const validateForm = () => {
    const newErrors: Record<string, string> = {};
    
    Object.keys(formData).forEach(field => {
      const error = validateProductField(field as keyof CreateProductRequest, formData[field]);
      if (error) {
        newErrors[field] = error;
      }
    });
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  return {
    formData,
    errors,
    touched,
    updateField,
    validateField,
    validateForm,
    setTouched
  };
}
```

#### 使用Zustand进行全局状态管理
```typescript
// 产品状态管理
interface ProductStore {
  products: Product[];
  loading: boolean;
  error: string | null;
  selectedProduct: Product | null;
  
  // Actions
  fetchProducts: (params?: ProductQueryParams) => Promise<void>;
  createProduct: (data: CreateProductRequest) => Promise<void>;
  updateProduct: (uuid: string, data: UpdateProductRequest) => Promise<void>;
  deleteProduct: (uuid: string) => Promise<void>;
  selectProduct: (product: Product | null) => void;
  clearError: () => void;
}

const useProductStore = create<ProductStore>((set, get) => ({
  products: [],
  loading: false,
  error: null,
  selectedProduct: null,

  fetchProducts: async (params) => {
    set({ loading: true, error: null });
    
    try {
      const response = await apiClient.getProducts(params);
      set({ products: response, loading: false });
    } catch (error) {
      set({ error: error.message, loading: false });
    }
  },

  createProduct: async (data) => {
    set({ loading: true, error: null });
    
    try {
      const newProduct = await apiClient.createProduct(data);
      set(state => ({
        products: [...state.products, newProduct],
        loading: false
      }));
    } catch (error) {
      set({ error: error.message, loading: false });
    }
  },

  // ... 其他actions
}));
```

### 4. 样式开发规范

#### 使用Tailwind CSS
```typescript
// 基础按钮样式
const buttonBaseClasses = 'inline-flex items-center justify-center font-medium rounded-md transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2';

const buttonVariants = {
  primary: 'bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500',
  secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300 focus:ring-gray-500',
  danger: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-500',
  success: 'bg-green-600 text-white hover:bg-green-700 focus:ring-green-500'
};

const buttonSizes = {
  sm: 'px-3 py-1.5 text-sm',
  md: 'px-4 py-2 text-base',
  lg: 'px-6 py-3 text-lg'
};

// Button组件实现
const Button: React.FC<ButtonProps> = ({
  variant = 'primary',
  size = 'md',
  disabled = false,
  loading = false,
  onClick,
  children,
  className = '',
  ...props
}) => {
  const classes = cn(
    buttonBaseClasses,
    buttonVariants[variant],
    buttonSizes[size],
    {
      'opacity-50 cursor-not-allowed': disabled || loading,
      'cursor-pointer': !disabled && !loading
    },
    className
  );

  return (
    <button
      className={classes}
      disabled={disabled || loading}
      onClick={onClick}
      {...props}
    >
      {loading && <LoadingSpinner size="sm" className="mr-2" />}
      {children}
    </button>
  );
};
```

#### CSS模块化
```css
/* Button.module.css */
.button {
  composes: base-button from global; /* 继承全局基础样式 */
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-weight: 500;
  border-radius: 0.375rem;
  transition: all 0.2s;
}

.button:focus {
  outline: none;
  ring: 2px;
  ring-offset: 2px;
}

.primary {
  background-color: rgb(37 99 235);
  color: white;
}

.primary:hover {
  background-color: rgb(29 78 216);
}

.primary:focus {
  ring-color: rgb(59 130 246);
}

/* 响应式设计 */
@media (max-width: 640px) {
  .button {
    font-size: 0.875rem;
    padding: 0.5rem 1rem;
  }
}
```

### 5. 表单处理规范

#### 使用React Hook Form
```typescript
// 产品表单组件
interface ProductFormData {
  productName: string;
  productCode: string;
  unitPrice: number;
  currentQuantity: number;
  minQuantity: number;
  maxQuantity: number;
  supplierUuid: string;
}

const ProductForm: React.FC<ProductFormProps> = ({
  initialData,
  isEdit = false,
  onSubmit,
  onCancel,
  loading = false,
  suppliers
}) => {
  const {
    register,
    handleSubmit,
    formState: { errors, isDirty },
    watch,
    setValue,
    reset
  } = useForm<ProductFormData>({
    defaultValues: initialData || {
      productName: '',
      productCode: '',
      unitPrice: 0,
      currentQuantity: 0,
      minQuantity: 0,
      maxQuantity: 0,
      supplierUuid: ''
    }
  });

  const watchedValues = watch();

  // 自定义验证规则
  const validateProductCode = async (value: string) => {
    if (!value) return '产品编码不能为空';
    
    if (!/^[A-Z0-9]{3,20}$/.test(value)) {
      return '产品编码必须为3-20位大写字母和数字';
    }
    
    // 检查编码是否已存在（编辑模式下排除当前产品）
    if (isEdit && initialData?.productCode === value) {
      return true;
    }
    
    try {
      const exists = await apiClient.checkProductCodeExists(value);
      return exists ? '产品编码已存在' : true;
    } catch (error) {
      return '验证失败，请重试';
    }
  };

  const handleFormSubmit = async (data: ProductFormData) => {
    try {
      await onSubmit(data);
      // 提交成功后重置表单或跳转
      if (!isEdit) {
        reset();
      }
    } catch (error) {
      // 错误处理
      console.error('提交失败:', error);
    }
  };

  return (
    <form onSubmit={handleSubmit(handleFormSubmit)} className="space-y-6">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* 产品名称 */}
        <FormField
          label="产品名称"
          error={errors.productName}
          required
        >
          <Input
            {...register('productName', {
              required: '产品名称不能为空',
              minLength: { value: 2, message: '产品名称至少2个字符' },
              maxLength: { value: 100, message: '产品名称不能超过100个字符' }
            })}
            placeholder="请输入产品名称"
          />
        </FormField>

        {/* 产品编码 */}
        <FormField
          label="产品编码"
          error={errors.productCode}
          required
        >
          <Input
            {...register('productCode', {
              required: '产品编码不能为空',
              validate: validateProductCode
            })}
            placeholder="请输入产品编码"
          />
        </FormField>

        {/* 单价 */}
        <FormField
          label="单价"
          error={errors.unitPrice}
          required
        >
          <Input
            type="number"
            step="0.01"
            min="0"
            {...register('unitPrice', {
              required: '单价不能为空',
              min: { value: 0, message: '单价不能为负数' }
            })}
            placeholder="0.00"
          />
        </FormField>

        {/* 供应商 */}
        <FormField
          label="供应商"
          error={errors.supplierUuid}
          required
        >
          <Select
            {...register('supplierUuid', {
              required: '请选择供应商'
            })}
            options={suppliers.map(s => ({
              value: s.uuid,
              label: s.supplierName
            }))}
            placeholder="请选择供应商"
          />
        </FormField>
      </div>

      {/* 库存数量设置 */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <FormField
          label="当前库存"
          error={errors.currentQuantity}
        >
          <Input
            type="number"
            min="0"
            {...register('currentQuantity', {
              min: { value: 0, message: '库存数量不能为负数' }
            })}
          />
        </FormField>

        <FormField
          label="最小库存"
          error={errors.minQuantity}
        >
          <Input
            type="number"
            min="0"
            {...register('minQuantity', {
              min: { value: 0, message: '最小库存不能为负数' },
              validate: (value) => {
                const maxQuantity = watchedValues.maxQuantity;
                if (maxQuantity > 0 && value > maxQuantity) {
                  return '最小库存不能大于最大库存';
                }
                return true;
              }
            })}
          />
        </FormField>

        <FormField
          label="最大库存"
          error={errors.maxQuantity}
        >
          <Input
            type="number"
            min="0"
            {...register('maxQuantity', {
              min: { value: 0, message: '最大库存不能为负数' },
              validate: (value) => {
                const minQuantity = watchedValues.minQuantity;
                if (value > 0 && minQuantity > value) {
                  return '最大库存不能小于最小库存';
                }
                return true;
              }
            })}
          />
        </FormField>
      </div>

      {/* 表单操作 */}
      <div className="flex justify-end space-x-4 pt-6">
        <Button
          type="button"
          variant="secondary"
          onClick={onCancel}
          disabled={loading}
        >
          取消
        </Button>
        
        <Button
          type="submit"
          variant="primary"
          loading={loading}
          disabled={!isDirty || loading}
        >
          {isEdit ? '更新产品' : '创建产品'}
        </Button>
      </div>
    </form>
  );
};
```

### 6. 表格组件规范

#### 可配置的数据表格
```typescript
// 数据表格组件
interface Column<T> {
  key: string;
  title: string;
  width?: number | string;
  sortable?: boolean;
  filterable?: boolean;
  render?: (value: any, record: T, index: number) => React.ReactNode;
}

interface DataTableProps<T> {
  columns: Column<T>[];
  data: T[];
  loading?: boolean;
  pagination?: {
    current: number;
    pageSize: number;
    total: number;
    onChange: (page: number, pageSize: number) => void;
  };
  selection?: {
    selectedRowKeys: string[];
    onSelectionChange: (selectedKeys: string[]) => void;
  };
  onSort?: (sortField: string, sortOrder: 'asc' | 'desc') => void;
  onFilter?: (filters: Record<string, any>) => void;
  rowKey?: string | ((record: T) => string);
  className?: string;
}

const DataTable = <T extends Record<string, any>>({
  columns,
  data,
  loading = false,
  pagination,
  selection,
  onSort,
  onFilter,
  rowKey = 'uuid',
  className = ''
}: DataTableProps<T>) => {
  const [sortConfig, setSortConfig] = useState<{
    field: string;
    order: 'asc' | 'desc';
  } | null>(null);

  const [filters, setFilters] = useState<Record<string, any>>({});

  const handleSort = (field: string) => {
    const newOrder = sortConfig?.field === field && sortConfig.order === 'asc' ? 'desc' : 'asc';
    const newSortConfig = { field, order: newOrder };
    
    setSortConfig(newSortConfig);
    onSort?.(field, newOrder);
  };

  const handleFilter = (field: string, value: any) => {
    const newFilters = { ...filters, [field]: value };
    setFilters(newFilters);
    onFilter?.(newFilters);
  };

  // 处理行选择
  const handleRowSelection = (record: T, selected: boolean) => {
    if (!selection) return;
    
    const key = typeof rowKey === 'function' ? rowKey(record) : record[rowKey];
    const newSelectedKeys = selected
      ? [...selection.selectedRowKeys, key]
      : selection.selectedRowKeys.filter(k => k !== key);
    
    selection.onSelectionChange(newSelectedKeys);
  };

  // 处理全选
  const handleSelectAll = (selected: boolean) => {
    if (!selection) return;
    
    const newSelectedKeys = selected
      ? data.map(record => typeof rowKey === 'function' ? rowKey(record) : record[rowKey])
      : [];
    
    selection.onSelectionChange(newSelectedKeys);
  };

  return (
    <div className={`overflow-hidden border border-gray-200 rounded-lg ${className}`}>
      {/* 表格头部 */}
      <div className="bg-gray-50 px-6 py-3 border-b border-gray-200">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-medium text-gray-900">数据表格</h3>
          <div className="flex items-center space-x-4">
            {/* 表格操作按钮 */}
            <Button variant="secondary" size="sm">
              导出
            </Button>
            <Button variant="primary" size="sm">
              新增
            </Button>
          </div>
        </div>
      </div>

      {/* 表格内容 */}
      <div className="overflow-x-auto">
        <table className="min-w-full divide-y divide-gray-200">
          <thead className="bg-gray-50">
            <tr>
              {/* 选择列 */}
              {selection && (
                <th className="w-12 px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  <input
                    type="checkbox"
                    checked={selection.selectedRowKeys.length === data.length && data.length > 0}
                    onChange={(e) => handleSelectAll(e.target.checked)}
                    className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                  />
                </th>
              )}
              
              {/* 数据列 */}
              {columns.map(column => (
                <th
                  key={column.key}
                  className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                  style={{ width: column.width }}
                >
                  <div className="flex items-center space-x-2">
                    <span>{column.title}</span>
                    
                    {/* 排序按钮 */}
                    {column.sortable && (
                      <button
                        onClick={() => handleSort(column.key)}
                        className="text-gray-400 hover:text-gray-600"
                      >
                        <SortIcon
                          direction={sortConfig?.field === column.key ? sortConfig.order : undefined}
                        />
                      </button>
                    )}
                    
                    {/* 过滤按钮 */}
                    {column.filterable && (
                      <FilterDropdown
                        value={filters[column.key]}
                        onChange={(value) => handleFilter(column.key, value)}
                      />
                    )}
                  </div>
                </th>
              ))}
              
              {/* 操作列 */}
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                操作
              </th>
            </tr>
          </thead>
          
          <tbody className="bg-white divide-y divide-gray-200">
            {loading ? (
              // 加载状态
              <tr>
                <td 
                  colSpan={columns.length + (selection ? 1 : 0) + 1}
                  className="px-6 py-4 text-center"
                >
                  <div className="flex justify-center items-center py-8">
                    <LoadingSpinner size="lg" />
                    <span className="ml-2 text-gray-500">加载中...</span>
                  </div>
                </td>
              </tr>
            ) : data.length === 0 ? (
              // 空数据状态
              <tr>
                <td 
                  colSpan={columns.length + (selection ? 1 : 0) + 1}
                  className="px-6 py-8 text-center"
                >
                  <div className="text-gray-500">
                    <EmptyIcon className="mx-auto h-12 w-12 text-gray-400" />
                    <p className="mt-2">暂无数据</p>
                  </div>
                </td>
              </tr>
            ) : (
              // 数据行
              data.map((record, index) => {
                const rowKeyValue = typeof rowKey === 'function' ? rowKey(record) : record[rowKey];
                const isSelected = selection?.selectedRowKeys.includes(rowKeyValue);
                
                return (
                  <tr
                    key={rowKeyValue}
                    className={cn({
                      'bg-blue-50': isSelected,
                      'hover:bg-gray-50': !isSelected
                    })}
                  >
                    {/* 选择列 */}
                    {selection && (
                      <td className="px-6 py-4 whitespace-nowrap">
                        <input
                          type="checkbox"
                          checked={isSelected}
                          onChange={(e) => handleRowSelection(record, e.target.checked)}
                          className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                        />
                      </td>
                    )}
                    
                    {/* 数据列 */}
                    {columns.map(column => (
                      <td key={column.key} className="px-6 py-4 whitespace-nowrap">
                        {column.render
                          ? column.render(record[column.key], record, index)
                          : record[column.key]
                        }
                      </td>
                    ))}
                    
                    {/* 操作列 */}
                    <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                      <div className="flex items-center justify-end space-x-2">
                        <Button
                          variant="secondary"
                          size="sm"
                          onClick={() => {/* 查看操作 */}}
                        >
                          查看
                        </Button>
                        <Button
                          variant="primary"
                          size="sm"
                          onClick={() => {/* 编辑操作 */}}
                        >
                          编辑
                        </Button>
                        <Button
                          variant="danger"
                          size="sm"
                          onClick={() => {/* 删除操作 */}}
                        >
                          删除
                        </Button>
                      </div>
                    </td>
                  </tr>
                );
              })
            )}
          </tbody>
        </table>
      </div>

      {/* 表格底部 */}
      {pagination && (
        <div className="bg-white px-6 py-3 border-t border-gray-200">
          <div className="flex items-center justify-between">
            <div className="text-sm text-gray-700">
              显示第 {(pagination.current - 1) * pagination.pageSize + 1} 到{' '}
              {Math.min(pagination.current * pagination.pageSize, pagination.total)} 条，
              共 {pagination.total} 条记录
            </div>
            
            <Pagination
              current={pagination.current}
              pageSize={pagination.pageSize}
              total={pagination.total}
              onChange={pagination.onChange}
            />
          </div>
        </div>
      )}
    </div>
  );
};
```

### 7. 错误处理规范

#### 错误边界组件
```typescript
// 错误边界组件
interface ErrorBoundaryProps {
  children: React.ReactNode;
  fallback?: React.ComponentType<{ error: Error; resetError: () => void }>;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    // 记录错误到日志系统
    console.error('组件错误:', error, errorInfo);
    
    // 发送错误报告
    this.reportError(error, errorInfo);
  }

  reportError = (error: Error, errorInfo: React.ErrorInfo) => {
    // 实现错误报告逻辑
    // 可以发送到Sentry、LogRocket等错误监控服务
  };

  resetError = () => {
    this.setState({ hasError: false, error: null });
  };

  render() {
    if (this.state.hasError) {
      const FallbackComponent = this.props.fallback || DefaultErrorFallback;
      return <FallbackComponent error={this.state.error!} resetError={this.resetError} />;
    }

    return this.props.children;
  }
}

// 默认错误回退组件
const DefaultErrorFallback: React.FC<{ error: Error; resetError: () => void }> = ({
  error,
  resetError
}) => (
  <div className="flex flex-col items-center justify-center min-h-[400px] p-8">
    <AlertTriangleIcon className="h-16 w-16 text-red-500 mb-4" />
    <h2 className="text-xl font-semibold text-gray-900 mb-2">
      出错了
    </h2>
    <p className="text-gray-600 mb-4 text-center">
      抱歉，发生了意外错误。请重试或联系技术支持。
    </p>
    <div className="space-x-4">
      <Button variant="primary" onClick={resetError}>
        重试
      </Button>
      <Button variant="secondary" onClick={() => window.location.reload()}>
        刷新页面
      </Button>
    </div>
    
    {/* 开发环境显示详细错误信息 */}
    {process.env.NODE_ENV === 'development' && (
      <details className="mt-4 text-left max-w-2xl">
        <summary className="cursor-pointer text-sm text-gray-500">
          错误详情（仅开发环境显示）
        </summary>
        <pre className="mt-2 p-4 bg-gray-100 rounded text-xs overflow-auto">
          {error.stack}
        </pre>
      </details>
    )}
  </div>
);
```

### 8. 测试规范

#### 组件单元测试
```typescript
// Button组件测试
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from './Button';

describe('Button', () => {
  it('渲染按钮文本', () => {
    render(<Button>点击我</Button>);
    expect(screen.getByText('点击我')).toBeInTheDocument();
  });

  it('触发点击事件', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>点击我</Button>);
    
    fireEvent.click(screen.getByText('点击我'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('禁用状态下不触发点击事件', () => {
    const handleClick = jest.fn();
    render(<Button disabled onClick={handleClick}>点击我</Button>);
    
    fireEvent.click(screen.getByText('点击我'));
    expect(handleClick).not.toHaveBeenCalled();
  });

  it('显示加载状态', () => {
    render(<Button loading>点击我</Button>);
    
    expect(screen.getByRole('button')).toBeDisabled();
    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument();
  });

  it('应用自定义类名', () => {
    render(<Button className="custom-class">点击我</Button>);
    
    expect(screen.getByRole('button')).toHaveClass('custom-class');
  });
});
```

#### 表单组件测试
```typescript
// ProductForm组件测试
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ProductForm } from './ProductForm';

const mockSuppliers: Supplier[] = [
  {
    uuid: 'supplier-1',
    supplierName: '测试供应商',
    supplierCode: 'TEST001',
    contactPerson: '张三',
    phone: '13800138000',
    email: 'test@example.com',
    address: '测试地址',
    isActive: true,
    createdAt: '2024-01-15T10:30:00Z',
    updatedAt: '2024-01-15T10:30:00Z'
  }
];

describe('ProductForm', () => {
  it('渲染表单字段', () => {
    render(<ProductForm suppliers={mockSuppliers} onSubmit={jest.fn()} />);
    
    expect(screen.getByLabelText(/产品名称/)).toBeInTheDocument();
    expect(screen.getByLabelText(/产品编码/)).toBeInTheDocument();
    expect(screen.getByLabelText(/单价/)).toBeInTheDocument();
    expect(screen.getByLabelText(/供应商/)).toBeInTheDocument();
  });

  it('验证必填字段', async () => {
    render(<ProductForm suppliers={mockSuppliers} onSubmit={jest.fn()} />);
    
    const submitButton = screen.getByRole('button', { name: /创建产品/ });
    fireEvent.click(submitButton);
    
    await waitFor(() => {
      expect(screen.getByText('产品名称不能为空')).toBeInTheDocument();
      expect(screen.getByText('产品编码不能为空')).toBeInTheDocument();
    });
  });

  it('提交表单数据', async () => {
    const mockSubmit = jest.fn();
    render(<ProductForm suppliers={mockSuppliers} onSubmit={mockSubmit} />);
    
    // 填写表单
    await userEvent.type(screen.getByLabelText(/产品名称/), '测试产品');
    await userEvent.type(screen.getByLabelText(/产品编码/), 'TEST001');
    await userEvent.type(screen.getByLabelText(/单价/), '100');
    
    // 选择供应商
    const supplierSelect = screen.getByLabelText(/供应商/);
    fireEvent.change(supplierSelect, { target: { value: 'supplier-1' } });
    
    // 提交表单
    const submitButton = screen.getByRole('button', { name: /创建产品/ });
    fireEvent.click(submitButton);
    
    await waitFor(() => {
      expect(mockSubmit).toHaveBeenCalledWith({
        productName: '测试产品',
        productCode: 'TEST001',
        unitPrice: 100,
        currentQuantity: 0,
        minQuantity: 0,
        maxQuantity: 0,
        supplierUuid: 'supplier-1'
      });
    });
  });
});

### 9. 性能优化规范

#### 使用React.memo优化渲染
```typescript
// 优化后的Button组件
const Button = React.memo<ButtonProps>(({
  variant = 'primary',
  size = 'md',
  disabled = false,
  loading = false,
  onClick,
  children,
  className = '',
  ...props
}) => {
  // 组件实现
});

Button.displayName = 'Button';
```

#### 使用useMemo和useCallback
```typescript
// 优化数据表格组件
const DataTable = <T extends Record<string, any>>({
  columns,
  data,
  // ...其他props
}: DataTableProps<T>) => {
  // 缓存排序配置
  const sortedData = useMemo(() => {
    if (!sortConfig) return data;
    
    return [...data].sort((a, b) => {
      const aValue = a[sortConfig.field];
      const bValue = b[sortConfig.field];
      
      if (sortConfig.order === 'asc') {
        return aValue < bValue ? -1 : aValue > bValue ? 1 : 0;
      } else {
        return aValue > bValue ? -1 : aValue < bValue ? 1 : 0;
      }
    });
  }, [data, sortConfig]);

  // 缓存事件处理函数
  const handleSort = useCallback((field: string) => {
    // 排序逻辑
  }, [onSort]);

  // 组件实现
};
```

### 10. 可访问性规范

#### 支持键盘导航
```typescript
// 支持键盘操作的按钮组件
const Button: React.FC<ButtonProps> = (props) => {
  const handleKeyDown = (event: React.KeyboardEvent) => {
    if (event.key === 'Enter' || event.key === ' ') {
      event.preventDefault();
      props.onClick?.(event as any);
    }
  };

  return (
    <button
      role="button"
      tabIndex={props.disabled ? -1 : 0}
      onKeyDown={handleKeyDown}
      {...props}
    >
      {props.children}
    </button>
  );
};
```

#### 支持屏幕阅读器
```typescript
// 可访问的表单字段
const FormField: React.FC<FormFieldProps> = ({
  label,
  error,
  required,
  children,
  id
}) => (
  <div className="space-y-2">
    <label 
      htmlFor={id}
      className="block text-sm font-medium text-gray-700"
    >
      {label}
      {required && <span className="text-red-500 ml-1">*</span>}
    </label>
    
    {React.cloneElement(children as React.ReactElement, {
      id,
      'aria-invalid': error ? 'true' : 'false',
      'aria-describedby': error ? `${id}-error` : undefined
    })}
    
    {error && (
      <p id={`${id}-error`} className="text-sm text-red-600" role="alert">
        {error}
      </p>
    )}
  </div>
);
```

## 组件发布流程

### 1. 开发阶段
- 编写组件代码和类型定义
- 添加单元测试和Storybook故事
- 确保代码通过ESLint检查

### 2. 测试阶段
- 运行所有测试用例
- 进行集成测试
- 检查可访问性

### 3. 文档阶段
- 更新组件文档
- 添加使用示例
- 编写变更日志

### 4. 发布阶段
- 提交代码审查
- 合并到主分支
- 发布新版本

## 最佳实践总结

### 代码质量
- 遵循单一职责原则
- 编写清晰的类型定义
- 添加详细的注释文档

### 性能优化
- 合理使用React.memo
- 缓存计算密集型操作
- 避免不必要的重新渲染

### 用户体验
- 提供加载状态反馈
- 实现错误边界处理
- 支持键盘导航操作

### 可维护性
- 保持组件接口稳定
- 提供向后兼容性
- 编写全面的测试用例

通过遵循这些规范，可以确保前端组件的质量、性能和可维护性，为进销存管理系统提供优秀的用户体验。